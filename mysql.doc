第二章
    1.innodb的一些知识
        1.1 select lock in share mode 和select for update
            select lock in share mode：共享锁，比如事物a执行了它，那其他事物能够读它锁定的行，但是不能修改，如果要修改只能等事物a提交才行；
            select for update：排他锁，事物a执行了它，那其他事物就不能访问或者修改它锁定的行；
        

第三章 架构优化和索引
1.  通常越小越好：就是要选择满足你数据需求最小长度；
    越简单越好：就是数据类型简单，cpu处理周期会变短；比如使用整数比较会比字符串好，使用mysql自建的时间数据结构（timestamp）比字符串好；
    尽量不用null，不利于使用索引，他会使mysql处理变得很复杂，所以除非一定存储null值，那么我们可以使用“”，0代替null；
2。  数据类型
    2.1 整数
        整数类型有 tinyint，smallint，mediumint，int，bigint，长度分别使8，16，24，32，64；那根据情况选择类型喽。其中int（1）和int（20）在
        存储空间和计算上没有什么区别，就是如果允许0填充，那么数的位数不够时需要加0补位。
    2.2 char和varchar
        char（10）在磁盘里面是固定长度的，比如你存储“hello”，那磁盘空间仍然是char（10），但是varchar（10）是根据实际值确定的，如果你存储“hello”；
        那么磁盘占用空间是5+1个长度，varchar另外使用1到2个字节来存储它的长度；但是在内存里面的临时表或者磁盘上的临时表就要为它分配固定大小长度，也
        就是10个字符的长度；嗯，还有utf-8这个字符集，英文是1一个字节，那中文是3个字节；
    2.3 日期和时间类型
        有两种datetime和timestamp，datetime表示时间范围大，需要8个字节的空间；
        那timestamp表示时间范围小，主要是只有4个字节来存储；
   2.4 标示符列
       其实就是自增列，特点是：数值类型，增量固定，不能是空值；

3.  索引基础知识
    索引对表的性能影响非常大，那索引的类型有b-tree索引，哈希索引；
    3.1 b-tree索引
        innodb是默认是：聚簇索引，数据结构是b-tree，那之所以称之为聚簇就是把主键索引和行数据都放在叶子结点上了；那innodb还有辅助索引，就是叶子结点
        存储的是索引和主键，需要在查找一个聚簇索引才能找到行数据；老大说对于聚簇索引最好是按照顺序插入，我理解的就是叶子节点也有指针指向下一个节点，
        如果不按照顺序插入的话可能会需要I/O操作。
        非聚簇索引：就是叶子结点存储的是索引和指针，该指针指向行数据；
     3.2    为排序使用索引扫描
        就是where和order by可以形成最左前缀的话可以使用索引，如果没有形成最左前缀，仍然不能使用索引。
     3.3    mysiam压缩索引
        可以压缩字符串索引，就是以第一个值为根据，其他往后的值：整数+后缀，比如第一个值是perform，第二个是performance，那可以记为7，ance；
4   索引使用总结
    http://blog.csdn.net/bigtree_3721/article/details/51340640     
        

第四章
1.查询优化
  1.1 缩短查询，使用分治法，把一个大的查询分成好几个小的查询；比如你要删除某个表，那可以每次删除1000条；
  1.2 分解连接，把一个联表查询变成几个单表查询，这样做的好处是单表查询的结果可以缓存；可以扩展数据库，不同的表放在不同的服务器上；对于大表使用IN代替联接
 2.sql语句查询过程
  客户端发送查询语句；服务器段先查看缓存，如果命中，直接返回结果；否则解析和预处理，优化查询，执行查询，最后返回查询结果；其中优化查询有若干种方式：min，
  max，count；in和or功能一样，但是in里面的进行了排序，查询效率logn；
3.  表排序
  3.1 双路排序：就是根据行指针和order by 那列进行排序，然后根据排序结果再依次从表中读取数据；需要读表两次
  3.2 单路排序：就是把所有的结果列读取到内存里面，然后在进行排序，这个耗内存；
4.  子查询
    select id from students  where id in （select id from  teachers）；
    上面这条语句不是先执行子查询，在执行外查询，而是 selec id from studens where exists （select * from teachers where teachers.id = studnets.id）；
    子查询效率并不高，使用的时候要注意；类似于
        for（students的id）{
            for（teachers的id）{
                if(students.id == teachers.id)
                    返回id；
            }
        }
     selec id from studens where not exists （select * from teachers where teachers.id = studnets.id）not exists类似于
        for（students[i].id）{
            for(teachers[j].id){
                    if(students[i].id == teachers[j].id)
                        放弃该id
            }
        }
      
    就是students的id和teachers的ID都不相等才符合条件；
    
    
   第五章  缓存
   1. 缓存命中
       只有查询语句（select）才缓存，并且select语句完全一样才去缓存，有些不确定函数，比如concurrent（）等不会缓存，并且缓存需要消耗时间
       去管理，如果表被修改，那缓存失效；
  2.   缓存如何使用内存
        有专门的内存池来保存缓存，内存池被分为若干块，每块都可以保存不同的内容，比如有的保存查询结果，有的是查询文本等。服务器查询数据时，只要
        有一行新的数据出来就立即把结果返回给客户端，他不会等结果全部出来了在发送；嗯，每当这个查询能够缓存时，就会分配固定大小的内存，如果不够了
        再接着分配
 3.缓存未命中的原因
    3.1 这个查询本身不能被缓存
    3.2 这个查询之前没有被缓存
    3.3 缓存失效
    3.4 由于内存碎片等原因缓存被清除；
 4. 缓存优化因素
   4.1   Query_cache_type:缓存是否被激活；
    
         Query_cache_size：分配给缓存的最大内存；
    
         Query_cache_min_res_unit：存储查询的最小块；
    
         Query_cache_limit：单个查询的最大块；
        
   4.2  减少缓存碎片，可以调节Query_cache_min_res_unit的值，或者限制大缓存Query_cache_limit，总之就是减少碎片喽；
   4.3 innodb 和查询缓存
        mysql4.0之前innodb事物不能使用缓存，从mysql4.1可以用，但是需要向服务器询问这个表能否使用缓存查询；如果表上有数据，不能使用，每一个表
        在innodb内部都有一个事物ID，如果事物的ID<表的ID，那该事物不能使用该表的缓存；
   4.4  通用缓存优化方式
        成批的写入数据，这样可以减少缓存失效次数；表的缓存不能太大，数据过大，清理需要时间过长，因此，可以设置query_cache_size的值
        
 第六章    配置优化
    1.变量作用域：全局，会话域，对象域；
    2.如何为mysql分配内存：mysql需要内存的上线，每个连接需要的缓存，操作系统需要的缓存；重要的缓存包括：操作系统为myisam缓存的数据，myisam键
    缓存，Innodb缓存池，查询缓存。
    3. myisam键缓存：myisam只缓存key，数据是操作系统帮忙缓存；但是myisam的数据块大小很重要，如果它不是正好4kb，步骤如下；
        3.1 从磁盘读取4kb内容，但只需要1kb，其他3kb丢掉；修改这1kb内容，（再从磁盘读取同样的4kb数据，将其中1kb替换掉，存储到磁盘）这部分如果数据块大小
        是4kb就可以避免了；
    4.  innodb缓存：innodb不仅缓存了索引，还有行数据，他需要更大的内存；

        
    
  
        
        
        
        
        
        
       
       
    
    
    
    
    
