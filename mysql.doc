第二章
    1.innodb的一些知识
        1.1 select lock in share mode 和select for update
            select lock in share mode：共享锁，比如事物a执行了它，那其他事物能够读它锁定的行，但是不能修改，如果要修改只能等事物a提交才行；
            select for update：排他锁，事物a执行了它，那其他事物就不能访问或者修改它锁定的行；
        

第三章 架构优化和索引
1.  通常越小越好：就是要选择满足你数据需求最小长度；
    越简单越好：就是数据类型简单，cpu处理周期会变短；比如使用整数比较会比字符串好，使用mysql自建的时间数据结构（timestamp）比字符串好；
    尽量不用null，不利于使用索引，他会使mysql处理变得很复杂，所以除非一定存储null值，那么我们可以使用“”，0代替null；
2。  数据类型
    2.1 整数
        整数类型有 tinyint，smallint，mediumint，int，bigint，长度分别使8，16，24，32，64；那根据情况选择类型喽。其中int（1）和int（20）在
        存储空间和计算上没有什么区别，就是如果允许0填充，那么数的位数不够时需要加0补位。
    2.2 char和varchar
        char（10）在磁盘里面是固定长度的，比如你存储“hello”，那磁盘空间仍然是char（10），但是varchar（10）是根据实际值确定的，如果你存储“hello”；
        那么磁盘占用空间是5+1个长度，varchar另外使用1到2个字节来存储它的长度；但是在内存里面的临时表或者磁盘上的临时表就要为它分配固定大小长度，也
        就是10个字符的长度；嗯，还有utf-8这个字符集，英文是1一个字节，那中文是3个字节；
    2.3 日期和时间类型
        有两种datetime和timestamp，datetime表示时间范围大，需要8个字节的空间；
        那timestamp表示时间范围小，主要是只有4个字节来存储；
   2.4 标示符列
       其实就是自增列，特点是：数值类型，增量固定，不能是空值；

3.  索引基础知识
    索引对表的性能影响非常大，那索引的类型有b-tree索引，哈希索引；
    3.1 b-tree索引
        innodb是默认是：聚簇索引，数据结构是b-tree，那之所以称之为聚簇就是把主键索引和行数据都放在叶子结点上了；那innodb还有辅助索引，就是叶子结点
        存储的是索引和主键，需要在查找一个聚簇索引才能找到行数据；老大说对于聚簇索引最好是按照顺序插入，我理解的就是叶子节点也有指针指向下一个节点，
        如果不按照顺序插入的话可能会需要I/O操作。
        非聚簇索引：就是叶子结点存储的是索引和指针，该指针指向行数据；
     3.2    为排序使用索引扫描
        就是where和order by可以形成最左前缀的话可以使用索引，如果没有形成最左前缀，仍然不能使用索引。
     3.3    mysiam压缩索引
        可以压缩字符串索引，就是以第一个值为根据，其他往后的值：整数+后缀，比如第一个值是perform，第二个是performance，那可以记为7，ance；
4   索引使用总结
    http://blog.csdn.net/bigtree_3721/article/details/51340640     
        

第四章
1.查询优化
  1.1 缩短查询，使用分治法，把一个大的查询分成好几个小的查询；比如你要删除某个表，那可以每次删除1000条；
  1.2 分解连接，把一个联表查询变成几个单表查询，这样做的好处是单表查询的结果可以缓存；可以扩展数据库，不同的表放在不同的服务器上；对于大表使用IN代替联接
 2.sql语句查询过程
  客户端发送查询语句；服务器段先查看缓存，如果命中，直接返回结果；否则解析和预处理，优化查询，执行查询，最后返回查询结果；其中优化查询有若干种方式：min，
  max，count；in和or功能一样，但是in里面的进行了排序，查询效率logn；
3.  表排序
  3.1 双路排序：就是根据行指针和order by 那列进行排序，然后根据排序结果再依次从表中读取数据；需要读表两次
  3.2 单路排序：就是把所有的结果列读取到内存里面，然后在进行排序，这个耗内存；
4.  子查询
    select * from students  where id in （select id from  teachers）；
    上面这条语句不是先执行子查询，在执行外查询，而是 selec * from studens where exists （select * from teachers where teachers.id = studnets.id）；
    子查询效率并不高，使用的时候要注意；  

